---
title: "PRÁCTICA MACHINE LEARNING I"
author: "Amanda Del Álamo Caballero y Alejandro Delgado Peribáñez"
date: "18/04/2022"
output: bookdown::gitbook

#output:
 # html_document:
  #  theme: paper
   # highlight: zenburn
    #code_folding: hide
    #toc: yes
    #toc_float: yes
    #toc_depth: 2
    #df_print: paged
  #pdf_document:
   # toc: yes
    #toc_depth: '1'

---

```{r setup, include=FALSE, warning=FALSE,message=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r}
library(dplyr)
library(caret)
library(ggplot2)
library(lattice)
library(class)
library(corrplot)
library(pROC)
library(caret)
library(lattice)
library(foreach)
library(iterators)
library(parallel)
library(doMC)
library(e1071)
library(ranger)
library(rpart)
library(rpart.plot)
library(NbClust)
library(psych)
library(factoextra)
library(ade4)
library(cluster)
library(lift)
library(dplyr)
library(readr)
library(mice)
library(stringr)
library(ggplot2)
library(tidyverse)
library(gamlss)
library(MASS)
library(doMC)
library(iterators)
library(gam)
library(stats)
library(splines)
library(foreach)
library(gamlss.data)
library(gamlss.dist)
library(NB)
library(gridExtra)
library(gmodels)
library(Hmisc)
library(ggthemes)
library(ellipse)
library(ggcorrplot)
library(corrplot)
library(leaps)
library(PerformanceAnalytics)
library(GGally)
library(psych)
library(carData)
library(car)
library(lmtest)
library(olsrr)
library(performance)
library(mice)
library(see)
library(lme4)
library(patchwork)
```

# Introducción

En esta sección se comenzarán a aplicar los algoritmos de aprendizaje automático (o *machine learning*) vistos en clase. Utilizaremos los siguientes algoritmos que podemos clasificar en:

* **Algoritmos no supervisados**: Parten de un conjunto de datos sin etiquetar y aplican inducción partiendo de ejemplos para predecir en nuevos datos. 

  + Análisis de componentes principales (reducción de la dimensionalidad)
  + k-medias. Análisis *cluster* no jerárquico o de conglomerados (*clustering*)
  + Análisis *cluster* jerárquico o de conglomerados (*clustering*)
  

* **Algoritmos supervisados**: Utilizan un conjunto de datos etiquetados y con ellas intentan encontrar relaciones entre las características y las etiquetas para predecir en nuevos datos.

  + Regresión logística 
  + Los k-vecinos más cercanos (k-NN: The k-nearest neighbours) (Basado en la información)
  + Árboles de decisión (Basado en la información)
  + Bosques aleatorios (Basado en la información)
  + Máquinas de vectores de soporte (SVM: Support Vector Machines) (Basado en el error)
  
Se carga, limpia, visualiza y secciona el conjunto de datos: 

```{r Carga de datos, message=FALSE, warning=FALSE}
data <- read.csv("train-ML.csv", na = c("","NA","NULL",NULL,"  ","/n" ))
head(data)
dataTest <- read.csv("test-ML.csv", na = c("","NA","NULL",NULL,"  ","/n" ))
head(dataTest)
```

```{r , message=FALSE, warning=FALSE}
library(dplyr)
data %>% dplyr::select(-Price.mod2) -> data
data %>% dplyr::select(-X) -> data
head(data)
data %>%
  mutate(Fuel_Type = as.factor(Fuel_Type)) %>%
  mutate(Transmission = as.factor(Transmission)) %>%
  mutate(Location = as.factor(Location)) -> data
data %>% mutate(Owner_Type = factor(Owner_Type, levels=c("First", "Second", "Third", "Fourth & Above"))) -> data

dataTest %>%
  mutate(Fuel_Type = as.factor(Fuel_Type)) %>%
  mutate(Transmission = as.factor(Transmission)) %>%
  mutate(Location = as.factor(Location)) -> dataTest

dataTest %>%
  mutate(Name = as.factor(Name)) %>%
  mutate(Make = as.factor(Make)) %>%
  mutate(Seats = as.factor(Seats))%>%
  mutate(Gama = as.factor(Gama))-> dataTest

data %>%
  mutate(Name = as.factor(Name)) %>%
  mutate(Make = as.factor(Make)) %>%
  mutate(Seats = as.factor(Seats))-> data

dataTest %>% mutate(Owner_Type = factor(Owner_Type, levels=c("First", "Second", "Third", "Fourth & Above"))) -> dataTest
```

# Análisis no supervisado

En primer lugar, comenzaremos viendo los algoritmos de aprendizaje no supervisado.

## Análisis de componentes principales

El análisis de componentes principales (en inglés, PCA) es una técnica utilizada para describir un conjunto de datos en términos de nuevas variables denominadas componentes no correlacionadas. Estas nuevas componentes se construyen a partir de las variables existentes, eso sí, debemos asegurarnos de que las variables utilizadas en PCA sean variables cuantitativas (no podemos usar variables cualitativas ni categóricas). Con esta técnica se pretende reducir la dimensionalidad del problema en cuestión.

```{r}
str(data)
#data
corrplot(cor(data[, c(3,4, 8, 9, 14, 15)]), method = "ellipse") 
corPlot(data[, c(3,4, 8, 9, 14, 15)], cex = 1.2, main = "Matriz de correlación")
corrplot(cor(data[, c(3,4, 8, 9, 14, 15)]),method = "circle",       order = "hclust",         hclust.method = "ward.D",
         addrect =2,rect.col = 3,rect.lwd = 3)  
```

```{r}
cortest(cor(data[, c(3,4, 8, 9, 14, 15)]))
```

Tenemos evidencias para decir que las correlaciones son distintas de 0.


```{r}
pca1 <- prcomp(data[, c(3,4, 8, 9, 14, 15)])
```


```{r}
plot(pca1)
```

```{r}
summary(pca1)
```

En nuestro conjunto de datos inicial, todas nuestras variables eran cuantitativas (menos la variable respuesta, que no utilizamos en aprendizaje no supervisado), sin embargo, las variables categorizadas que hemos creado no lo son. Así que haremos el análisis de componentes principales escalando las variables: Kilometers_Driven, Power, kmpl y kmpg.

```{r}
pca2 <- prcomp(data[, c(3,4, 8, 9, 14, 15)], scale=T)

pca2

```

Aquí arriba, podemos ver los diferentes pesos que otorga el análisis de componentes principales a cada una de las variables iniciales escaladas. Por ejemplo: en la primera componente principal (PC1), vemos que sobre todo se enfrentan las variables Engine y Power contra kmpl; en la segunda componente principal (PC2), vemos que se enfrenta la variable kmpg contra kmpl, Power,Year y Engine; en la tercera componente principal (PC3) se enfrentan los kilómetros que lleva recorridos el coche contra el año de fabricación y la variable kmpkg.

```{r}
summary(pca2)
```

La inercia de las primeras dimensiones muestra si existen relaciones fuertes entre las variables y sugiere el número de dimensiones que se deben estudiar.

Las dos primeras dimensiones de análisis expresan el 59,83% de la inercia total del conjunto de datos; eso quiere decir que el 59.83% de los individuos (o variables) nublan la variabilidad total que es explicada por el plano. Este porcentaje es relativamente alto y, por lo tanto, el primer plano representa bien la variabilidad de los datos. Este valor es muy superior al valor de referencia que equivale al 34,95%, por lo que la variabilidad explicada por este plano es muy significativa (el valor de referencia es el cuantil 0,95 de la distribución de porcentajes de inercia obtenida simulando 1689 tablas de datos de tamaño equivalente sobre la base de una distribución normal).

A partir de estas observaciones, conviene interpretar también las dimensiones mayores o iguales a la tercera.

Sin embargo, aquí resulta difícil ver algo claro e intuitivo, así que haremos un pequeño resumen y un gráfico multivariante para mostrar la información más relevante del PCA. Se estudia el plano 1:2.

```{r}
PC1= pca2[[2]][,1]
PC2= pca2[[2]][,2]
PC3= pca2[[2]][,3]
PC4= pca2[[2]][,4]

componentes_princ <- cbind(PC1,PC2,PC3,PC4)
componentes_princ
```


```{r}
plot(pca2)
biplot(pca2)
s.corcircle(componentes_princ[,-3], sub="PC1 Y PC2")
```

En el gráfico enfrentamos la primera y la segunda componente principal, y vemos como influyen cada una de las variables en los coches. Por ejemplo, el coche 1712, debe tener unos valores muy altos de Power y Engine que son las variables que "más tiran hacia la derecha", y el coche 745, según el `biplot` debe tener un valor muy alto de kilometers_driven, que es la variable que "más tira en esa dirección". Si recordamos lo analizado previamente, en la sección del análisis exploratorio de datos, este coche ya destacó por tener valores un tanto diferentes a los del resto por su desmesurado valor de kilómetros recorridos. Comprobamos que la información que nos proporciona el gráfico es totalmente coherente con lo que obtuvimos en el *EDA*.

La dimensión 1 opone individuos caracterizados por una coordenada fuertemente positiva en el eje (a la derecha del gráfico) a individuos caracterizados por una coordenada fuertemente negativa en el eje (a la izquierda del gráfico).

El grupo 1 (caracterizado por una coordenada positiva en el eje) comparte:

  - valores altos para la variable kmpkg.
  - valores bajos para las variables kmpl, Potencia y Motor (las variables se ordenan de la más débil).

El grupo 2 (caracterizado por una coordenada positiva en el eje) comparte:

  - valores altos para las variables Motor, Potencia y Kilómetros_Recorridos (las variables se ordenan de la más fuerte).
  - valores bajos para las variables kmpl, Year y kmpkg (las variables se ordenan de la más débil).

El grupo 3 (caracterizado por una coordenada negativa en el eje) comparte:

  - valores altos para las variables kmpl y Año (las variables se ordenan de la más fuerte).
  - valores bajos para las variables Motor, Potencia, Kilómetros_Conducidos y kmpkg (las variables se ordenan de menor a mayor).

La dimensión 2 opone individuos caracterizados por una coordenada fuertemente positiva en el eje (en la parte superior del gráfico) a individuos caracterizados por una coordenada fuertemente negativa en el eje (en la parte inferior del gráfico).

El grupo 1 (caracterizado por una coordenada positiva en el eje) comparte:

  - valores altos para las variables kmpl y Año (las variables se ordenan de la más fuerte).
  - valores bajos para las variables Motor, Potencia, Kilómetros_Conducidos y kmpkg (las variables se ordenan de menor a mayor).

El grupo 2 (caracterizado por una coordenada positiva en el eje) comparte:

  - valores altos para las variables Motor, Potencia y Kilómetros_Recorridos (las variables se ordenan de la más fuerte).
  - valores bajos para las variables kmpl, Year y kmpkg (las variables se ordenan de la más débil).

El grupo 3 (caracterizado por una coordenada negativa en el eje) comparte:

  - valores altos para la variable kmpkg.
  - valores bajos para las variables kmpl, Potencia y Motor (las variables se ordenan de la más débil).



```{r}


fviz_pca_var(pca2,axes = c(1,2), col.var = "cos2", alpha.var = "contrib" ) + theme_grey()
fviz_pca_var(pca2,axes = c(1,3), col.var = "cos2", alpha.var = "contrib" ) + theme_grey()

```

La suma de cos2 de una variable determinada sobre cada factor es 1. Esto significa que cada vector debería estar tocando el perímetro de la circunferencia unidad, pero no lo está haciendo ninguna prácticamente, ¿por qué?. Si observamos por ejemplo la variable Engine(al igual que Power), vemos que está muy cerca de tocar dicho perímetro, su proyección sobre las dimensiones 1 y 2 (componentes) indica su contribución a éstas, pero aún le falta algo de contribución que debe estar repartida por otra u otras dimensiones. Si está variable solo tuviese peso sobre las dos primeras dimensiones estaría tocando la circunferencia.

Podemos colorear las observaciones según alguna variable. Además podemos hacer que las variables que más contribuyen en este plano factorial, se resalten más que las que menos influencia tienen. También tenemos la posibilidad de dibujar elipses alrededor de cada grupo con un cierto nivel de confianza.

Como se aprecia en los gráficos anteriores, no tiene mucho sentido representar la segunda componente principal ya que no realiza un correcto enfrentamiento de variables y no nos aporta nada.

```{r}
summary(pca2)
```

Por otro lado, podemos decir que lo que más nos interesa de este resumen es la proporción de la varianza total que consigue explicar cada componente principal. Según el resumen que acabamos de mostrar arriba, vemos que la varianza total explicada no aumenta mucho a partir de la tercera o cuarta componente principal (y que con todas las componentes principales, evidentemente, la varianza explicada es el 100%). Para visualizar esto haremos un gráfico de barras:

```{r}
screeplot(pca2, xlab="PCs")
```

Una estimación del número correcto de ejes a interpretar sugiere restringir el análisis a la descripción de los 3 primeros ejes. Estos ejes presentan una inercia superior a las obtenidas por el cuantil 0,95 de las distribuciones aleatorias (78,56% frente a 51,79%). Esta observación sugiere que solo estos ejes llevan una información real. En consecuencia, la descripción se situará en estos ejes.

```{r}

scree(data[, c(3,4, 8, 9, 14, 15)],main ="Grafico_de_Sedimentacion")
```

El grafico de sedimentación nos muestra la cantidad óptima de componentes a tomar en el análisis, siendo los valores por encima de la linea de 1.0 los más aceptables.

```{r}
fa.parallel(data[, c(3,4, 8, 9, 14, 15)],fa="pc")
```

Según los resultados del análisis paralelo, el número de componentes deberá ser 3. 

Se comprueba que con PCA no se consigue lo que se busca, ni PC2 ni PC3 nos sirven para realizar una correcta redimensión de los datos. Nos damos cuenta de que nuestro problema es bastante difícil de resolver, dado que es complicado ver algún tipo de separación o tendencia de los coches en función de las variables explicativas o incluso en cuanto al precio. Aún así, si nos fijamos, en los gráficos que enfrentan PC1 con PC2, PC1 con PC3 y PC2 con PC3, parece que los coches de gama media y gama alta están más dispersos que los de gama baja.


## k-medias. Análisis *cluster* no jerárquico o de conglomerados (*clustering*)

El análisis *cluster* busca agrupar individuos u observaciones tratando de lograr la máxima homogeneidad en cada grupo o *cluster* y la mayor diferencia entre los grupos. Es decir, el *clustering* asigna individuos similares al mismo grupo, y observaciones muy distintas estarán en grupos diferentes. Nosotros usaremos el algoritmo de las k-medias que tiene como objetivo encontrar y agrupar en clases a las observaciones que tienen una alta similitud entre ellos. Esta similitud se define como la menor distancia entre características de cada observación. Cuanto más cerca estén los puntos de datos, más similares serán y más probabilidad habrá de que pertenezcan al mismo *cluster*. Para ello, primero debemos escoger una distancia y dado que nuestra variable respuesta está bastante bien balanceada, usaremos la distancia euclídea. Esta es la distancia que muchos métodos de *R* utilizan por defecto, pero debemos asegurarnos de que los datos que introducimos en el algoritmo están escalados (para que no tengan mayor importancia las variables con números más grandes en valor absoluto, por el mero de hecho de que puedan estar medidas en diferentes unidades, por ejemplo). Así y para trabajar sobre una variable respuesta binaria, transformamos la variable Gama. 

```{r}
data <- data[,-13]
data %>% 
  mutate(
    Gama = case_when( 
      data$Make=="Datsun" |data$Make=="Smart" |data$Make=="Tata" |data$Make=="Fiat" |data$Make=="Chevrolet" |data$Make=="Ambassador" |
      data$Make=="Skoda"|data$Make=="Renault" |data$Make=="Ford" |data$Make=="Honda"|data$Make=="Volkswagen" |data$Make=="Hyundai" |data$Make=="Nissan" |data$Make=="Maruti" ~ "Baja-media",
      data$Make=="Bentley"|data$Make=="Porsche" |data$Make=="Land Rover" |data$Make=="Jaguar" |data$Make=="Mini" |data$Make=="Mercedes-Benz" |data$Make=="Audi" |data$Make=="Bmw" |data$Make=="Jeep" |data$Make=="Volvo" |data$Make=="Isuzu" |data$Make=="Mitsubishi" |data$Make=="Toyota" |data$Make=="Force" |data$Make=="Mahindra"~ "Alta"
    )
  ) -> data

data$Gama <- as.factor(data$Gama)

#dataTest %>% dplyr::select(-Mileage) -> dataTest
dataTest %>% dplyr::select(-X) -> dataTest
head(dataTest)
dataTest%>%drop_na() -> dataTest
dataTest %>% 
    mutate(kmpl = ifelse(Fuel_Type=="Diesel" | Fuel_Type=="Petrol", Mileage, 0)) %>%
    mutate(kmpkg = ifelse(Fuel_Type=="CNG" | Fuel_Type=="LPG", Mileage, 0)) %>%
    dplyr::select(-Mileage) -> dataTest

dataTest %>% 
  mutate(
    Gama = case_when( 
      dataTest$Make=="Datsun" |dataTest$Make=="Smart" |dataTest$Make=="Tata" |dataTest$Make=="Fiat" |dataTest$Make=="Chevrolet" |dataTest$Make=="Ambassador" |
      dataTest$Make=="Skoda"|dataTest$Make=="Renault" |dataTest$Make=="Ford" |dataTest$Make=="Honda"|dataTest$Make=="Volkswagen" |dataTest$Make=="Hyundai" |dataTest$Make=="Nissan" |dataTest$Make=="Maruti" ~ "Baja-media",
      dataTest$Make=="Bentley"|dataTest$Make=="Porsche" |dataTest$Make=="Land Rover" |dataTest$Make=="Jaguar" |dataTest$Make=="Mini" |dataTest$Make=="Mercedes-Benz" |dataTest$Make=="Audi" |dataTest$Make=="Bmw" |dataTest$Make=="Jeep" |dataTest$Make=="Volvo" |dataTest$Make=="Isuzu" |dataTest$Make=="Mitsubishi" |dataTest$Make=="Toyota" |dataTest$Make=="Force" |dataTest$Make=="Mahindra"~ "Alta"
    )
  ) -> dataTest

```


```{r escalado de datos}
TrainEscalado <- data %>% dplyr::select(Year, Kilometers_Driven, Engine, Power, Price, kmpl) %>% scale() %>% as.data.frame()
```


Como mínimo haremos dos grupos, es decir, buscaremos hacer 2 o más grupos, porque hacer un único *cluster* no tiene ningún sentido, ya que buscamos separar los coches en una característica que toma dos valores: gama baja-media y gama alta. 


Para decidir el número óptimo de grupos que debemos crear, podemos usar la función `NbClust` de *R*, que nos devuelve cuál es (según unos criterios) el mejor número de *clusters* para el algoritmo de k-medias o bien, podemos ir probando con diferentes valores y decidir nosotros en función de la información que recabemos.

Primero usaremos la función, teniendo en cuenta que como máximo aceptaremos tener 10 grupos y como mínimo 2:

```{r cluster k-medias 1}

set.seed(220322)
nc = NbClust(TrainEscalado,min.nc=2,max.nc=10,method = "kmeans")
nc
```

La función `NbClust` prueba con diferente número de grupos y evalúa cuál es número óptimo de *clusters* según algunos criterios (muestra los resultados gráficos de la aplicación de algunos de ellos). Vemos que finalmente, nos dice que el número óptimo de grupos es 3, dado que es en el que más criterios de optimalidad coinciden.

Ahora, tras probar nosotros manualmente con diferente número de grupos, comprobamos que las mejores maneras para agrupar a los coches en función de la gama que tienen es creando 3,4 u 8 grupos. 

```{r cluster k-medias 2}

# Ponemos una semilla para obtener siempre los mismos 3 grupos
set.seed(20112090)
km0 = kmeans(x=TrainEscalado, nstart = 5, centers = 3)
km0$centers #km2$[2]
tkm0 <- table(km0$cluster,data$Gama)
tkm0

# Ponemos una semilla para obtener siempre los mismos 4 grupos
set.seed(22032023)

km1 = kmeans(x=TrainEscalado, nstart = 5, centers = 4)
km1$centers #km1$[2]
tkm1 <- table(km1$cluster,data$Gama)
tkm1

# Ponemos una semilla para obtener siempre los mismos 8 grupos
set.seed(20112020)
km2 = kmeans(x=TrainEscalado, nstart = 5, centers = 8)
km2$centers #km2$[2]
table(km2$cluster,data$Gama)

# Ponemos una semilla para obtener siempre los mismos 8 grupos
set.seed(201120572)
km3 = kmeans(x=TrainEscalado, nstart = 5, centers = 9)
km3$centers #km2$[2]
table(km3$cluster,data$Gama)
```


Para no complicar demasiado el entendimiento del algoritmo, decidimos quedarnos con 3 *clusters*:

+ En el primer *cluster*, sobre todo, clasifica a los coches con valores altos de Price, Engine y Power. En esta categoría tenemos `r sum(km0$cluster==1)` coches, es decir, al `r round(sum(km0$cluster==1)/dim(data)[1]*100,2)`% del total.

+ En el segundo *cluster*, si nos fijamos, clasifica a los coches con valores medios en casi todas las variables, con año de fabricación antiguo y kmpl alto. En esta categoría tenemos `r sum(km0$cluster==2)` coches, es decir, al `r round(sum(km0$cluster==2)/dim(data)[1]*100,2)`% del total.

+ En el tercer *cluster*, clasificamos a los coches con valores bajos en Precio, Engine y Power. En esta categoría tenemos `r sum(km0$cluster==3)` coches relativamente comunes (sin valores atípicos o muy influyentes en ninguna de sus variables), es decir, al `r round(sum(km0$cluster==3)/dim(data)[1]*100,2)`% del total.

Fijándonos en la tabla que nos devuelve, vemos que en el primer grupo la mayoría de los coches son de gama alta (el `r round(tkm0[1,1]/(tkm0[1,1]+tkm0[1,2])*100,2)`%); en el segundo grupo, los coches están bastante mezclados aunque son mayoría en la clase de gama media-baja pero necesitaríamos analizarlos más en profundidad para poder separarlos mejor (`r round(tkm0[2,2]/(tkm0[2,1]+tkm0[2,2])*100,2)`% de coches de gama alta frente a un `r round(tkm0[2,1]/(tkm0[2,1]+tkm0[2,2])*100,2)`% de coches de gama media o baja); y en el tercer grupo, al contario que en el primero, la mayoría son de gama baja o media (un `r round(tkm0[3,2]/(tkm0[3,1]+tkm0[3,2])*100,2)`%)

Veamos esto que acabamos de explicar con algunos gráficos.

Según los *cluster* que hemos formado, si enfrentamos el precio (dominante en el grupo 1 con valores altos) frente a la variable Engine (dominante en el grupo 3 con valores bajos), deberíamos obtener un gráfico en el que los *cluster* 1 y 3 estuviesen bien diferenciados y el 2, que tenía valores medios, esté mezclado con ambos.

```{r cluster k-medias 3}
plot(TrainEscalado$Engine, TrainEscalado$Price, col=km0$cluster, pch=19 , cex=2, xlab = "Engine", ylab="Price", main = "Engine vs Price")
legend(-2,12,c("Cluster 1","Cluster 2","Cluster 3"),fill = (unique(sort(km0$cluster))))
```

Observamos como los coches de los *cluster* 1 y 3 están perfectamente separados. Además, esperábamos que el *cluster* 3 estuviese mezclado con los otros dos, sin embargo, vemos que enfrentando estas dos variables, separamos muy bien los tres grupos pese a que si que se juntan en ciertos coches.

Podríamos seguir haciendo gráficos y comprobaciones, pero con eso ya vemos que tenemos una buena forma de clasificar a algunos de los coches. En el grupo 1 teníamos mayoritariamente coches de gama alta; en el grupo 2, mezcla; y en el grupo 3, coches de gama baja o media. Hemos comprobado que los grupos 1 y 3 se separan muy bien gráficamente, pero de hecho, los grupos 1 y 2 también, dado que donde más "mezcla apreciamos es entre los *cluster* 2 y 3. Esto nos es de gran ayuda.


## Clustering jerárquico 

Para realizar el *clustering* jerárquico, también utilizaremos la distancia euclídea. Pero debemos definir cuál será la distancia entre dos grupos, que será la que nos sirva como criterio para decidir cuando se deben unir dos *cluster*. En *R* podemos definir diferentes distancias entre ellos (distancias entre los centroides de cada grupo, distancias entre los elementos más próximos de cada grupo, distancias entre los elementos más alejados de cada grupo...). Veremos cuál es el resultado de utilizar alguna de ellas mostrando los dendrogramas asociados a cada una.

En el primer caso utilizaremos el método *single* (distancia entre los elementos más cercanos de cada *cluster*): 

```{r cluster jerárquico 1}
#TrainEscalado[-745,] <- TrainEscalado
hc1 = hclust(d=dist(TrainEscalado), method = "single" )
plot(hc1)
```

En este dendrograma, podemos ver que tenemos un coche atípico (el 745), que se acumula a la izquierda.

En el segundo caso utilizaremos el método *complete* (distancia entre los elementos más alejados de cada *cluster*): 

```{r cluster jerárquico 2}
hc2 = hclust(d=dist(TrainEscalado), method = "complete")
plot(hc2)
```

En este caso sucede algo parecido a lo que ocurría antes, el coche 745, vuelve a aparecer "al margen" del resto, y vuelve a destacar por ser uno de los últimos coches en agruparse en el dendrograma, aunque ya se empiezan a visualizar diferentes agrupaciones.

En el tercer caso utilizaremos el método *average* (distancia media entre las observaciones de cada *cluster*): 

```{r cluster jerárquico 3}
hc3 = hclust(d=dist(TrainEscalado), method = "average" )
plot(hc3)
```

En este tercer caso, de nuevo, volvemos a observar que el coche 745 está más separado del resto que los demás entre sí, y que es este coche el que provoca el "retraso" de la unión de las diferentes agrupaciones iniciales.

En el cuarto y último caso utilizaremos el método *centroid* (distancia entre los centroides de cada *cluster*): 

```{r cluster jerárquico 4}
hc4 = hclust(d=dist(TrainEscalado), method = "centroid" )
plot(hc4)
```

De nuevo, volvemos a identificar al coche 745 a la izquierda, y volvemos a comprobar cómo es este coche el que produce un mayor retraso en la última unión de todos los grupos.

Como ya se vio en el análisis exploratorio de datos, podríamos pensar en eliminarlo, pero como tampoco tenemos más información y no sabemos si en realidad son *outliers* o simplemente tienen características un poco diferentes a las de los demás, decidimos quedarnos con ellos, ya que puede que nos aparezca más adelante otro coche similar a alguno de ellos, y nos ayuden a clasificarlo adecuadamente.

Por último, tomando el segundo dendrograma, que parece ser en el que mejor se observan las diferentes agrupaciones, vamos a proceder a tomar únicamente 3 grupos (igual que hicimos en el *clustering* no jerárquico).

```{r cluster jerárquico 5}
plot(hc2)
rect.hclust(hc2, k=4, border = "blue")
```

Con esto vemos que tenemos un *cluster* principal en el que se aglutinan la mayoría de los coches y otros dos formados por muy pocos coches (los más atípicos de los extremos del dendrograma). Veamos cómo al formar 10 grupos se observan mejor la subdivisiones.

```{r cluster jerárquico 6}
plot(hc2)
rect.hclust(hc2, k=10, border = "blue")
```


# Análisis supervisado

## Regresión logística

La división de los coches en gama baja-media y gama alta ha sido necesaria también para poder realizar la regresión logística sobre la nueva variable. 

Se realizan las siguientes gráficas para visualizar los datos con la nueva variable:

```{r}
table(data$Gama)
ggplot(data, aes(x = Power, y = Price, color = Gama)) + geom_point()
ggplot(data, aes(x = Engine, y = Price, color = Gama)) + geom_point()
ggplot(data, aes(x = Transmission, y = Price, color = Gama)) + geom_point()
ggplot(data, aes(x = Seats, y = Price, color = Gama)) + geom_point()
ggplot(data, aes(x = Owner_Type, y = Price, color = Gama)) + geom_point()
```

Ahora, se van a aplicar los modelos con distintas covariables para buscar el mejor de ellos:

```{r}
# modelos lineales generalizados estimados por MLE
logit <- glm( 
  Gama ~Power+Seats+Transmission+Owner_Type+Engine, 
  data = data, 
  family = binomial()
)
summary(logit)

logit2 <- glm( 
  Gama ~Owner_Type+Seats+Transmission+Engine, 
  data = data, 
  family = binomial()
)
summary(logit2)

logit3 <- glm( 
  Gama ~Power+Transmission+Engine, 
  data = data, 
  family = binomial()
)
summary(logit3)
```

La interpretación de los p-valores es similar a la del modelo lineal. Podemos ver que las variables Engine,Power y Transmission son significativas en el modelo (p-valor mucho menor de 0.05), mientras que la variable Seats y Owner_Type influyen más en un modelo que en otro.

El mejor modelo es el explicado por las variables Power, Engine y Transmission. 
En cuanto a los coeficientes, la interpretación cambia. El modelo GLM no ajusta la variable respuesta sino una función de enlace. En el caso del modelo logit esta función es: $η=log(p1−p)$,
siendo $p$ la probabilidad de que el individuo tome el valor “1” correspondiente a la gama alta en la variable dicotómica. Al cociente $p/(1−p)$ se le conoce como odds ratio. Por tanto, los coeficientes del modelo logit se interpretan como el logaritmo del odds ratio. Si nos fijamos en el coeficiente de la variable Transmission (0.63) en el modelo 3, nos está indicando que el logaritmo del odds ratio de pertenecer al grupo de los coches de alta gama aumenta 0.63 unidades por cada unidad que aumenta la variable Transmission.

Antes de comenzar con las siguientes, lo que debemos hacer es definir una medida de precisión para contrastar los datos una vez que tengamos cada matriz de confusión y comparar los resultados que nos ofrecen cada uno de los métodos que empleemos. En nuestro caso, la variable respuesta no está muy bien balanceada:

```{r análisis supervisado}
summary(data$Gama)
```

Como vemos, los coches de gama alta se corresponden con el 30% aproximadamente y los de gama baja-media, el 70%. Supondremos que están más o menos equilibradas. No queremos dar más valor a identificar un tipo de coche frente al otro. Por tanto, se establecerá la siguiente **medida de precisión**.
Esta es una medida de precisión que hemos creado para tener en cuenta todos los casos, tanto los falsos negativos como los falsos positivos. En realidad, se trata de la **media geométrica de la sensitividad** (*recall*) **y la especificidad**, y se define según la siguiente expresión:

$$\text{Medida de precisión}=\sqrt{\frac{TP}{FN+TP}·\frac{TN}{FP+TN}}=\sqrt{TPR·TNR} $$
donde:

- $TP$ (*true positive*) son los coches de gama alta que acertamos que son de gama alta.

- $TN$ (*true negative*) son los coches de gama baja-media que acertamos que son de baja-media.

- $FP$ (*false positive*) son los coches de gama baja-media que nosotros predecimos como gama alta.

- $FN$ (*false negative*) son los coches de gana alta que nosotros predecimos como de gama baja-media.

- $TPR$ (*sensitivity, recall, hit rate or true positive rate*) es la sensitividad.

- $TNR$ (*specificity, dplyr::selectivity or true negative rate*) es la especificidad.

Cabe señalar que esta medida sólo será utilizada en futuros análisis cuando el problema requiera de una precisión de este tipo, mientras, se utilizará como métrica el accuracy.

```{r medida de precisión}
medidaPrecision <- function(matrizDeConfusion){
  return(sqrt(matrizDeConfusion[1,1]*matrizDeConfusion[2,2]/((matrizDeConfusion[1,2]+matrizDeConfusion[2,2])*(matrizDeConfusion[2,1]+matrizDeConfusion[1,1]))))
}
```


## Los k-vecinos más cercanos (k-NN: The k-nearest neighbours)

El método de los k-vecinos más cercanos consiste en clasificar a un nuevo individuo en función de la categoría de sus $k$ vecinos más cercanos, es decir, clasificaremos un coche en gama alta o gama media-baja en función de la gama de los coches más cercanos a él (con cercanía nos referimos a similitud entre sus características).


```{r}
# Ponemos una semilla para que siempre nos salga el mismo resultado (el algoritmo es aleatorio)
set.seed(07122020)
```


```{r}
trainX <- data[,c(2:10,13,14)]
preProcValues <- preProcess(x = trainX,method = c("center", "scale"))
preProcValues
```

Para poder realizar las predicciones, se entrena mediante cross-validation y así se estima el número óptimo de vecinos.

```{r}
set.seed(400)
ctrl <- trainControl(method="repeatedcv",repeats = 3)
knnFit <- train(Gama ~ ., data = data[,c(2:10,13,14,15)], method = "knn", trControl = ctrl, preProcess = c("center","scale"), tuneLength = 20)
knnFit
```

```{r}
plot(knnFit)
```

```{r}
knnPredict <- predict(knnFit,newdata =dataTest[,c(2:10,13,14,15)])
data$Gama <- factor(data$Gama,levels=c("Alta","Baja-media"),labels=c("Alta","Baja-media"))
dataTest$Gama <- factor(dataTest$Gama,levels=c("Alta","Baja-media"),labels=c("Alta","Baja-media"))
confusionMatrix(knnPredict, dataTest$Gama )
```

```{r}
accuracy <- mean(knnPredict == dataTest$Gama)
accuracy
```


```{r}
error = 1-accuracy
error
```

```{r}
table(knnPredict,dataTest$Gama)
```

Por tanto, tomando el número óptimo de vecinos para realizar las predicciones, tenemos una precisión del 91'5%.

## Árboles de decisión

Los árboles de decisión se construyen en base al cumplimiento o no de ciertos criterios en torno a las variables explicativas de los datos. Digamos que comenzamos comprobando un cierto criterio sobre la variable más explicativa. Si el criterio se cumple, nos vamos por una rama; si no, nos vamos por la otra. Por cada una de ellas, volveremos a comprobar otro cierto criterio, y así hasta llegar a las hojas. Las hojas clasifican a los datos en un grupo u otro. Todo esto lo explicaremos mucho mejor cuando construyamos nuestros árboles de decisión.

Primero veremos cuál es el valor óptimo de `cp` (parámetro de complejidad que combina la tasa de error con la profundidad del árbol). Para ello, construiremos un árbol muy complejo, y en función de los resultados que obtengamos lo "podaremos".

```{r árboles de decisión 1}

arbolDecisionInfoComplejo <- rpart(data[,15] ~., data[,c(2:10,13,14)], cp=0.001,  method="class",parms=list(split="information"))
plotcp(arbolDecisionInfoComplejo)
```

En el gráfico vemos que el mínimo se encuentra en torno al 0,0036, así que para obtener el mejor compromiso entre error y profundidad nos quedaremos con un valor de `cp`=0,004, porque tenemos que tener en cuenta que cuanto más pequeño sea este valor, más complejo y profundo será el árbol y menos error tendremos, sin embargo, corremos el riesgo de sobreajustar el modelo (problema de *overfitting*). Por otro lado, podemos usar dos criterios diferentes: el de información y el de Gini. Usaremos los dos y comprobaremos con cuál obtenemos una mayor precisión.

Comenzamos con el árbol de decisión utilizando el criterio de información.

```{r}
arbolDecision <- rpart(data[,15] ~., data[,c(2:10,13,14)], cp=0.004,  method="class",parms=list(split="information"))
arbolDecision
```

Aquí tenemos nuestro árbol de decisión. Como vemos, la primera pregunta (2 y 3) que le hará a un nuevo coche es si su motor es mayor o igual  o menor a 1690. Si es mayor o igual a 1690, le preguntará si la potencia es inferior a 164.2 (preguntas 4 y 5); y si es que no, preguntará si el tipo de combustible es de diésel o petróleo(preg 8 y 9). Si es de diésel, entonces habrá que fijarse en el número de asientos que posea el coche. En este punto del árbol, si el número de asientos es 7, se volverá a clasificar por el motor, en función de si es mayor a 2299 en el que cerraremos la rama del árbol observando si la variable kmpl es inferior a 10. Así se ha llegado a un nodo hoja (marcados en asterisco) como por ejemplo llegar hasta la condición 69 y cumplirla, donde se clasifica el coche en gama media-baja o gama alta (dependiendo de la hoja en cuestión a la que haya llegado el coche).
Como acabamos de señalar, las variables más informativas de nuestro árbol son el motor y la potencia de los coches. Tiene sentido que esto sea así, y que la primera característica sobre la que "pregunte" el árbol para clasificar a un nuevo coche sea Engine. ¿Por qué? Porque tal y como vimos, en la sección del análisis exploratorio de datos, justo era ésta la covariable más relacionada con gama de los coches. Así que los resultados obtenidos son perfectamente coherentes con todo el estudio realizado hasta el momento.

Aquí tenemos las preguntas que se han hecho a lo largo del árbol.

```{r árboles de decisión 3}
labels(arbolDecision, pretty=T)
```

Los errores que se cometen en cada hoja y el error total del árbol:

```{r}
printcp(arbolDecision)
rpart.plot(arbolDecision, uniform=T);
```


Vamos a comprobar la precisión del árbol con los mismos datos con los que ha sido construido.

```{r árboles de decisión 5}
predArbolInfo1 = predict(arbolDecision, data[,c(2:10,13,14)])
# Redondeamos la predicción para obtener un resultado 0-1
predArbolInfo1 = round(predArbolInfo1)
tArb1 = table(predArbolInfo1[,1], data[,15])
tArb2 = table(predArbolInfo1[,2], data[,15])
medidaPrecision(tArb2)
```

Obtenemos una precisión del 97% con los datos de entrenamiento. Ahora, vamos a ver como clasifica nuestro árbol a nuevos coches. Para ello usaremos el conjunto de datos de testing y calcularemos la medida de precisión del resultado.

```{r árboles de decisión 6}
predArbolInfo2 = predict(arbolDecision,dataTest[,c(2:10,14,15)])
# Redondeamos la predicción para obtener un resultado 0-1
predArbolInfo2 = round(predArbolInfo2)
tArb3 = table(predArbolInfo2[,1], dataTest[,13])
tArb4 = table(predArbolInfo2[,2], dataTest[,13])
#medidaPrecision(tArb3)
medidaPrecision(tArb4)
```

Con el conjunto de datos de testing se obtiene una precisión del 95%, lo que nos indica que nuestro árbol de decisión realiza buenas predicciones y no sobreajusta el modelo.

Por otro lado, vamos a ver cuál es la precisión que obtenemos utilizando el criterio de Ginni. Construimos un nuevo árbol:

```{r árboles de decisión 7}
arbolDecisionGini <- rpart(data[,15] ~., data=data[,c(2:10,13,14)], cp=0.004, parms=list(split="gini"))
arbolDecisionGini
```

Vamos a comprobar el error que comete el árbol de decisión y qué aspecto tiene:

```{r árboles de decisión 8}
labels(arbolDecisionGini, pretty=T)
printcp(arbolDecisionGini)
rpart.plot(arbolDecisionGini, uniform=T)
```

La precisión que se obtiene con los datos de entrenamiento es la siguiente:

```{r árboles de decisión 9}
predArbolGini1 = predict(arbolDecisionGini,data[,c(2:10,13,14)])
# Redondeamos la predicción para obtener un resultado 0-1
predArbolGini1 = round(predArbolGini1)
tArb5 = table(predArbolGini1[,1], data[,15])
tArb6 = table(predArbolGini1[,2], data[,15])
medidaPrecision(tArb6)
```

Se obtiene un accuracy del 95%. Además, con el conjunto de datos de testing se obtiene la siguiente métrica:

```{r árboles de decisión 10}
predArbolGini2 = predict(arbolDecisionGini, dataTest[,c(2:10,14,15)])
predArbolGini2=round(predArbolGini2)
tArb7 = table(predArbolGini2[,1],dataTest[,13])
tArb8 = table(predArbolGini2[,2],dataTest[,13])
pArb1 = medidaPrecision(tArb7)
pArb2 = medidaPrecision(tArb8)
pArb2
```

Comprobamos que tanto con el conjunto de entrenamiento como con el conjunto de prueba las precisiones que obtenemos son muy buenas también con Gini, en este caso se obtiene un 93% en test por lo que consideramos buenos árboles de decisión. Distinguiendo entre el árbol de información y el del criterio de Gini, seleccionamos el de información por cometer menos error y ajustarse más a las nuevas entradas que se le proporcionan.

## Bosques aleatorios

Un bosque de árboles o bosque aleatorio es un conjunto de árboles de decisión tales que los nodos de cada árbol dependen de los valores de un subconjunto de variables muestreado aleatoriamente. Es decir, para construir cada árbol se escogen un subconjunto del total de las variables explicativas. Cuando tenemos el bosque construido lo que hacemos es "pasar" los nuevos datos por todos los árboles del bosque. Cada árbol clasificará al dato en una clase, y el bosque, finalmente, clasificará al dato en la clase en la que más árboles hayan coincidido.

Una vez que sabemos qué es un bosque aleatorio cabe preguntarse cuál es el número óptimo de árboles que debemos construir y cuántas variables queremos que se seleccionen para cada
uno de los árboles. Para descubrir esto, probaremos con distintos valores de cada uno y nos quedaremos con el que mejor medida de precisión nos proporcione.

Durante todo el proceso de análisis se han evaluado cada una de las métricas. Al obtener una precisión del 97% en entrenamiento y 95% en testing en árboles de decisión, se ha hecho constatar que no seleccionaremos como mejor método para predecir el de bosques aleatorios o random forest ya que al obtener esa precisión tan alta, siempre será mejor tener un árbol que un bosque de árboles en cuanto a complejidad y coste. No obstante, se realizan algunos cálculos para estimar cual sería la precisión y las predicciones de este bosque. 

```{r prueba Ranger}

set.seed(123)

modelo <- ranger(
  formula = as.factor(data[,15]) ~ .,
  data = data[,c(2:10,13,14)],
  num.trees = 10,
  seed = 123
)
```


```{r}
predicciones <- predict(modelo, data = dataTest[,c(2:10,14,15)])
predicciones
#test_rmse <- sqrt(mean((predicciones - as.factor(data[,13]))^2))
#paste("Error de test (rmse) del modelo (log): ", round(test_rmse,2))
```

## Máquinas de vectores de soporte (SVM: Support Vector Machines)

Vamos a aplicar SVM a nuestros datos. Las SVM constituyen un método basado en aprendizaje para la resolución de problemas de clasificación y regresión. En ambos casos, esta resolución se basa en una primera fase de entrenamiento (donde se les informa con múltiples ejemplos ya resueltos, en forma de pares {problema, solución}) y una segunda fase de uso para la resolución de problemas. En ella, las SVM se convierten en una “caja negra” que proporciona una respuesta (salida) a un problema dado (entrada).

```{r svm 1}

svmdata = data[,c(2:10,13,14,15)]
```

Lo primero que hacemos es separar el conjunto de datos en los conjuntos de train y test, estableciendo el 70% de ellos para train y el 30% para test.

```{r svm 2}
ind <- sample(2,nrow(svmdata), replace= TRUE, prob = c(0.7,0.3))
trainSet <- svmdata[ind==2,]
testSet <- svmdata[ind==1,]
```

Realizamos el entrenamiento del modelo. Vamos a probar los distintos kernels para comprobar cual de ellos aprende mejor. 

### SVM con kernel radial

Suponiendo que una observación del conjunto de datos de test se encuentra alejada de una observación de entrenamiento en términos de distancia euclídea, el kernel radial tiene un comportamiento muy local, en el sentido de que sólo las observaciones de entrenamiento cercanas a una observación de test tendrán efecto sobre su clasificación. Es importante tener en cuenta que una mayor flexibilidad no tiene porque mejorar las predicciones debido a que un modelo muy flexible puede ajustarse demasiado a los datos de entrenamiento.

Primero, entrenamos el modelo:

```{r svm 3}
model <- svm(Gama~., data = trainSet, kernel="radial")
prediccion <- predict(model, newdata= testSet[-12])
```

Ahora, se muestra el resultado mediante la matriz de confusión:

```{r svm 4}
MC <- table(testSet[,12], prediccion)
MC
accuracy <- (sum(diag(MC)))/(sum(MC))
accuracy
```

Como se puede observar, el modelo clasifica bien en un 92% de los casos, por lo que las predicciones son realmente buenas.

### SVM con kernel lineal

El kernel lineal cuantifica la similitud de un par de observaciones usando la correlación de Pearson. Con un kernel lineal, el clasificador obtenido es equivalente a un support vector classifier. Se entrena y se muestran los resultados a continuación:

```{r svm 5}
model2 <- svm(Gama~., data = trainSet, kernel="linear")
prediccion <- predict(model2, newdata= testSet[-12])

MC <- table(testSet[,12], prediccion) 
MC
accuracy <- (sum(diag(MC)))/(sum(MC))
accuracy
```

Se obtiene un accuracy del 92%, por lo que predice con bastante exactitud al igual que el kernel radial. 

### SVM con kernel sigmoidal 

Ahora, con el kernel sigmoidal:

```{r svm 6}
model3 <- svm(Gama~., data = trainSet, kernel="sigmoid")
prediccion <- predict(model3, newdata= testSet[-12])

MC <- table(testSet[,12], prediccion)
MC
accuracy <- (sum(diag(MC)))/(sum(MC))
accuracy
```

Se obtiene un accuracy del 92%, por lo que predice con bastante exactitud al igual que el kernel radial y lineal. 

### SVM con kernel polinomial

El kernel polinómico de grado d (siendo d>1) permite un límite de decisión mucho más flexible. Cuando un support vector classifier se combina con un kernel no lineal, se obtiene un support vector machine. Se entrena el modelo y se muestran los resultados: 

```{r svm 7}
model4 <- svm(Gama~., data = trainSet, kernel="polynomial")
prediccion <- predict(model4, newdata= testSet[-12])

MC <- table(testSet[,12], prediccion)
MC
accuracy <- (sum(diag(MC)))/(sum(MC))
accuracy
```

Tanto el kernel radial como el lineal y el sigmoidal obtienen la misma métrica, por lo tanto esos hiperplanos se adaptan correctamente a nuestros datos.

# Ajuste de los hiperparámetros del modelo 

Muchos modelos, entre ellos los árboles de regresión, contienen parámetros que no pueden aprenderse a partir de los datos de entrenamiento y, por lo tanto, deben de ser establecidos por el analista. A estos se les conoce como hiperparámetros. Los resultados de un modelo pueden depender en gran medida del valor que tomen sus hiperparámetros, sin embargo, no se puede conocer de antemano cuál es el adecuado. Aunque con la práctica, los especialistas en machine learning ganan intuición sobre qué valores pueden funcionar mejor en cada problema, no hay reglas fijas. La forma más común de encontrar los valores óptimos es probando diferentes posibilidades.

   - Escoger un conjunto de valores para el o los hiperparámetros.

   - Para cada valor (combinación de valores si hay más de un hiperparámetro), entrenar el modelo y estimar su error mediante un método de validación

   - Finalmente, ajustar de nuevo el modelo, esta vez con todos los datos de entrenamiento y con los mejores hiperparámetros encontrados.

## Regresión logística

El método glm de caret emplea la función glm() del paquete básico de R. Este algoritmo no tiene ningún hiperparámetro pero, para que efectúe una regresión logística, hay que indicar family = "binomial".

```{r}
registerDoMC(cores = 4)
```

Se configuran el número de repeticiones y las particiones para cada repetición:

```{r}
particiones  <- 10
repeticiones <- 5
```

Ahora, se ajustan los hiperparámetros:

```{r}
hiperparametros <- data.frame(parameter = "none")

set.seed(123)
seeds <- vector(mode = "list", length = (particiones * repeticiones) + 1)
for (i in 1:(particiones * repeticiones)) {
  seeds[[i]] <- sample.int(1000, nrow(hiperparametros))}
seeds[[(particiones * repeticiones) + 1]] <- sample.int(1000, 1)

```

Y por último, se define el entrenamiento y se ajusta el modelo:

```{r}
# DEFINICIÓN DEL ENTRENAMIENTO
control_train <- trainControl(method = "repeatedcv", number = particiones,
                              repeats = repeticiones, seeds = seeds,
                              returnResamp = "final", verboseIter = FALSE,
                              allowParallel = TRUE)
```


```{r}
# AJUSTE DEL MODELO
set.seed(34220)
modelo_logistic <- train(Gama ~ ., data = data[,c(2:10,13,14,15)],
                         method = "glm",
                         tuneGrid = hiperparametros,
                         metric = "Accuracy",
                         trControl = control_train,
                         family = "binomial")
modelo_logistic
```

Empleando un modelo de regresión logística se consigue un accuracy promedio de validación del 93%.

## k-NN

Ahora aplicamos la busqueda bayesiana para encontrar el mejor número de vecinos para el k-NN.


```{r}
# Hiperparámetros
hiperparametros <- data.frame(k = c(1, 2, 5, 10, 15, 20, 30, 50))

set.seed(123)
seeds <- vector(mode = "list", length = (particiones * repeticiones) + 1)
for (i in 1:(particiones * repeticiones)) {
  seeds[[i]] <- sample.int(1000, nrow(hiperparametros)) 
}
seeds[[(particiones * repeticiones) + 1]] <- sample.int(1000, 1)
```

```{r}
# DEFINICIÓN DEL ENTRENAMIENTO

control_train <- trainControl(method = "repeatedcv", number = particiones,
                              repeats = repeticiones, seeds = seeds,
                              returnResamp = "final", verboseIter = FALSE,
                              allowParallel = TRUE)
```


```{r}
# AJUSTE DEL MODELO

set.seed(34220)
modelo_knn <- train(Gama~ ., data = data[,c(2:10,13,14,15)],
                    method = "knn",
                    tuneGrid = hiperparametros,
                    metric = "Accuracy",
                    trControl = control_train)
modelo_knn
```

```{r}
# REPRESENTACIÓN GRÁFICA
ggplot(modelo_knn, highlight = TRUE) +
  scale_x_continuous(breaks = hiperparametros$k) +
  labs(title = "Evolución del accuracy del modelo KNN", x = "K") +
  theme_bw()
```

Con un modelo k-NN con 5 vecinos se consigue un accuracy de validación promedio del 89'7%. 

## Árboles de decisión

Ahora, vamos a realizar el ajuste de hiperparámetros del árbol de decisión, que ya obtenía muy buenas predicciones.

```{r}
# Hiperparámetros
hiperparametros <- data.frame(parameter = "none")

set.seed(123)
seeds <- vector(mode = "list", length = (particiones * repeticiones) + 1)
for (i in 1:(particiones * repeticiones)) {
  seeds[[i]] <- sample.int(1000, nrow(hiperparametros))
}
seeds[[(particiones * repeticiones) + 1]] <- sample.int(1000, 1)
```


```{r}
# DEFINICIÓN DEL ENTRENAMIENTO
control_train <- trainControl(method = "repeatedcv", number = particiones,
                              repeats = repeticiones, seeds = seeds,
                              returnResamp = "final", verboseIter = FALSE,
                              allowParallel = TRUE)
```

```{r}
# AJUSTE DEL MODELO
set.seed(34220)
modelo_C50Tree <- train(Gama~ ., data = data[,c(2:10,13,14,15)],
                    method = "C5.0Tree",
                    tuneGrid = hiperparametros,
                    metric = "Accuracy",
                    trControl = control_train)
modelo_C50Tree
```

```{r}
summary(modelo_C50Tree$finalModel)
```

Empleando como modelo un árbol simple C5.0, se consigue un accuracy promedio de validación del 98'1%.

## Random Forest

El método ranger de caret emplea la función ranger() del paquete ranger. Este algoritmo tiene 3 hiperparámetros:

  - mtry: número predictores seleccionados aleatoriamente en cada árbol.

  - min.node.size: tamaño mínimo que tiene que tener un nodo para poder ser dividido.

  - splitrule: criterio de división.

Aunque caret también incluye el método rf con la función rf() del paquete randomForest, este último solo permite optimizar el hiperparámetro mtry.

```{r}
# Hiperparámetros
hiperparametros <- expand.grid(mtry = c(3, 4, 5, 7),
                               min.node.size = c(2, 3, 4, 5, 10, 15, 20, 30),
                               splitrule = "gini")

set.seed(123)
seeds <- vector(mode = "list", length = (particiones * repeticiones) + 1)
for (i in 1:(particiones * repeticiones)) {
  seeds[[i]] <- sample.int(1000, nrow(hiperparametros))
}
seeds[[(particiones * repeticiones) + 1]] <- sample.int(1000, 1)
```

```{r}
# DEFINICIÓN DEL ENTRENAMIENTO
control_train <- trainControl(method = "repeatedcv", number = particiones,
                              repeats = repeticiones, seeds = seeds,
                              returnResamp = "final", verboseIter = FALSE,
                              allowParallel = TRUE)

```


```{r}
# AJUSTE DEL MODELO

set.seed(34220)
modelo_rf <- train(Gama ~ ., data = data[,c(2:10,13,14,15)],
                   method = "ranger",
                   tuneGrid = hiperparametros,
                   metric = "Accuracy",
                   trControl = control_train,
                   # Número de árboles ajustados
                   num.trees = 500)
modelo_rf
```


```{r}
modelo_rf$finalModel
```


```{r}
# REPRESENTACIÓN GRÁFICA
ggplot(modelo_rf, highlight = TRUE) +
  scale_x_continuous(breaks = 1:30) +
  labs(title = "Evolución del accuracy del modelo Random Forest") +
  guides(color = guide_legend(title = "mtry"),
         shape = guide_legend(title = "mtry")) +
  theme_bw()
```

Empleando un modelo random forest con mtry = 7, min.node.size = 2 y splitrule = "gini", se consigue un accuracy promedio de validación del 98'4%. 

## SVM

El método svmRadial de caret emplea la función ksvm() del paquete kernlab. Este algoritmo tiene 2 hiperparámetros:

  - sigma: coeficiente del kernel radial.
  
  - C: penalización por violaciones del margen del hiperplano.

Se ajustan los hiperparámetros y se entrena el modelo con kernel radial:

```{r}
# Hiperparámetros
hiperparametros <- expand.grid(sigma = c(0.001, 0.01, 0.1, 0.5, 1),
                               C = c(1 , 20, 50, 100, 200, 500, 700))

set.seed(123)
seeds <- vector(mode = "list", length = (particiones * repeticiones) + 1)
for (i in 1:(particiones * repeticiones)) {
  seeds[[i]] <- sample.int(1000, nrow(hiperparametros))
}
seeds[[(particiones * repeticiones) + 1]] <- sample.int(1000, 1)
```

```{r}
# DEFINICIÓN DEL ENTRENAMIENTO
control_train <- trainControl(method = "repeatedcv", number = particiones,
                              repeats = repeticiones, seeds = seeds,
                              returnResamp = "final", verboseIter = FALSE,
                              allowParallel = TRUE)

```


```{r message=TRUE}
# AJUSTE DEL MODELO

set.seed(342)
modelo_svmrad <- train(Gama ~ ., data = data[,c(2:10,13,14,15)],
                   method = "svmRadial",
                   tuneGrid = hiperparametros,
                   metric = "Accuracy",
                   trControl = control_train)
modelo_svmrad
```

```{r}
modelo_svmrad$finalModel
```

```{r}
# REPRESENTACIÓN GRÁFICA
ggplot(modelo_svmrad, highlight = TRUE) +
  labs(title = "Evolución del accuracy del modelo SVM Radial") +
  theme_bw()
```

Empleando un modelo SVM Radial con sigma = 0.01 y C = 20, se consigue un accuracy promedio de validación del 93%. 

# Evaluación y comparación de modelos

Para poder determinar si un método es superior a otro, no es suficiente con comparar los mínimos (o máximos dependiendo de la métrica) que ha conseguido cada uno, sino que hay que tener en cuenta sus varianzas para determinar si existen evidencias suficientes de superioridad.

Al tratarse de modelos entrenados y validados sobre los mismos datos, mismas particiones y en el mismo orden (siempre que se haya asegurado la reproducibilidad mediante semillas), se pueden emplear métodos estadísticos para datos dependientes.

```{r}
modelos <- list(KNN = modelo_knn, logistic = modelo_logistic,
                arbol = modelo_C50Tree, rf = modelo_rf,
                SVMradial = modelo_svmrad)

resultados_resamples <- resamples(modelos)
```

Se modifica el conjunto de datos para separar el nombre de cada modelo y las distintas métricas en la tabla:

```{r}
metricas_resamples <- resultados_resamples$values %>%
                         gather(key = "modelo", value = "valor", -Resample) %>%
                         separate(col = "modelo", into = c("modelo", "metrica"),
                                  sep = "~", remove = TRUE)
```


```{r}
metricas_resamples %>% 
  group_by(modelo, metrica) %>% 
  summarise(media = mean(valor)) %>%
  spread(key = metrica, value = media) %>%
  arrange(desc(Accuracy))
```


```{r}
metricas_resamples %>%
  filter(metrica == "Accuracy") %>%
  group_by(modelo) %>% 
  summarise(media = mean(valor)) %>%
  ggplot(aes(x = reorder(modelo, media), y = media, label = round(media, 2))) +
    geom_segment(aes(x = reorder(modelo, media), y = 0,
                     xend = modelo, yend = media),
                     color = "grey50") +
    geom_point(size = 7, color = "firebrick") +
    geom_text(color = "white", size = 2.5) +
    scale_y_continuous(limits = c(0, 1)) +
    # Accuracy basal
    geom_hline(yintercept = 0.88, linetype = "dashed") +
    labs(title = "Validación: Accuracy medio repeated-CV",
         subtitle = "Modelos ordenados por media",
         x = "modelo") +
    coord_flip() +
    theme_bw()
```

```{r}
metricas_resamples %>% filter(metrica == "Accuracy") %>%
  group_by(modelo) %>% 
  mutate(media = mean(valor)) %>%
  ungroup() %>%
  ggplot(aes(x = reorder(modelo, media), y = valor, color = modelo)) +
    geom_boxplot(alpha = 0.6, outlier.shape = NA) +
    geom_jitter(width = 0.1, alpha = 0.6) +
    scale_y_continuous(limits = c(0, 1)) +
    # Accuracy basal
    geom_hline(yintercept = 0.88, linetype = "dashed") +
    theme_bw() +
    labs(title = "Validación: Accuracy medio repeated-CV",
         subtitle = "Modelos ordenados por media") +
    coord_flip() +
    theme(legend.position = "none")
```

El modelo random forest consigue el accuracy promedio más alto, seguido muy de cerca por el árbol de decisión y SVM. Para determinar si las diferencias entre ellos son significativas, se recurre a test estadísticos. Como se comentó al principio, teniendo en cuenta las métricas obtenidas por cada uno de ellos, siempre es menos complejo y costoso seleccionar el árbol de decisión por delante de un bosque de árboles.


### Test de Friedman para comparar el accuracy de los modelos 

```{r}
matriz_metricas <- metricas_resamples %>% filter(metrica == "Accuracy") %>%
                   spread(key = modelo, value = valor) %>%
                   dplyr::select(-Resample, -metrica) %>% as.matrix()
friedman.test(y = matriz_metricas)
```

Para un nivel de significancia (α = 0.05), el test de Friedman sí encuentra evidencias para rechazar la hipótesis nula de que los  clasificadores consiguen la misma precisión, sin embargo, no determina que par o pares son diferentes. Para identificarlos, se recurre a contrastes post HOC.

La función diff() del paquete caret recibe como argumento los resultados de validación de dos o más modelos extraídos con resample() y hace comparaciones por pares aplicando un t-test pareado con correcciones por comparaciones múltiples. Esta función no permite mucha flexibilidad en cuanto a las comparaciones, por lo que, una vez extraídos los datos con resample(), suele ser preferible emplear otras funciones disponibles en R.


```{r}
# Comparaciones múltiples con un test suma de rangos de Wilcoxon
metricas_accuracy <- metricas_resamples %>% filter(metrica == "Accuracy")
comparaciones  <- pairwise.wilcox.test(x = metricas_accuracy$valor, 
                                        g = metricas_accuracy$modelo,
                                        paired = TRUE,
                                        p.adjust.method = "holm")

# Se almacenan los p_values en forma de dataframe
comparaciones <- comparaciones$p.value %>%
  as.data.frame() %>%
  rownames_to_column(var = "modeloA") %>%
  gather(key = "modeloB", value = "p_value", -modeloA) %>%
  na.omit() %>%
  arrange(modeloA) 

comparaciones
```


Acorde a las comparaciones por pares, no existen evidencias suficientes para considerar que la capacidad predictiva de los modelos es distinta.


# Curva de ROC

Las curvas ROC (Receiver Operating Characteritic curve) permiten evaluar, en problemas de clasificación binaria, cómo varia la proporción de verdaderos positivos (sensibilidad o recall) y la de falsos positivos (1-especificidad) dependiendo del cutoff de probabilidad empleado en las asignaciones. El gráfico resultante es muy útil para identificar el cutoff que consigue un mejor equilibrio sensibilidad-especificidad. Además de esto, la curva ROC, en concreto el área bajo la curva (AUC), puede emplearse como métrica para evaluar modelos. Un modelo que clasifica perfectamente las dos clases tiene un 100% de sensibilidad y especificidad, por lo que el área bajo la curva es de 1. Un modelo que predice por debajo de lo esperado por azar, tiene un AUC menor de 0.5. Una condición necesaria para crear una curva ROC es disponer de la probabilidad de clases en las predicciones.

En caret, se puede sustituir la métrica accuracy empleada por defecto en problemas de clasificación y calcular en su lugar el AUC. Para ello, se tienen que indicar los argumentos summaryFunction = twoClassSummary y classProbs = TRUE en el control de entrenamiento. El segundo argumento es necesario porque el cálculo de la curva ROC requiere las probabilidades predichas para cada clase. Además del área bajo la curva, se calcula la sensibilidad y la especificidad para un cutoff de 0.5.

El paquete pROC contiene múltiples funciones para crear, representar y obtener métricas a partir de curvas ROC. Como argumentos se necesitan únicamente las probabilidades predichas para cada clase y la clase verdadera a la que pertenece cada observación.


```{r}

# Se obtienen las probabilidades predichas para cada clase
predicciones <- predict(object = modelo_logistic,
                        newdata = dataTest[,c(2:10,13,14,15)],
                        type = "prob")
# Cálculo de la curva
curva_roc <- roc(response = dataTest$Gama, 
                 predictor = predicciones$Alta) 

# Gráfico de la curva
plot(curva_roc)
```

```{r}
# Área bajo la curva AUC
auc(curva_roc)
```

```{r}
# Intervalo de confianza de la curva
ci.auc(curva_roc, conf.level = 0.95)
```

Con la regresión logística se consigue un área bajo la curva del 94%.

Ahora, veamos la curva ROC para el modelo k-nn.

```{r}

# Se obtienen las probabilidades predichas para cada clase
predicciones <- predict(object = modelo_knn,
                        newdata = dataTest[,c(2:10,13,14,15)],
                        type = "prob")
# Cálculo de la curva
curva_roc <- roc(response = dataTest$Gama, 
                 predictor = predicciones$Alta) 

# Gráfico de la curva
plot(curva_roc)
```


```{r}
# Área bajo la curva AUC
auc(curva_roc)
```

```{r}
# Intervalo de confianza de la curva
ci.auc(curva_roc, conf.level = 0.95)
```

Ahora, para el modelo de árbol de decisión: 

```{r}
# Se obtienen las probabilidades predichas para cada clase
predicciones <- predict(object = modelo_C50Tree,
                        newdata = dataTest[,c(2:10,13,14,15)],
                        type = "prob")
# Cálculo de la curva
curva_roc <- roc(response = dataTest$Gama, 
                 predictor = predicciones$Alta) 

# Gráfico de la curva
plot(curva_roc)
```


```{r}
# Área bajo la curva AUC
auc(curva_roc)
```

```{r}
# Intervalo de confianza de la curva
ci.auc(curva_roc, conf.level = 0.95)
```
El área bajo la curva del árbol de decisión es de 99%, por lo que se realiza un buen diagnóstico con este modelo. 

# GAM

En los modelos GAM se pueden aplicar funciones (lineales o no lineales) a cada uno de los predictores. El paquete gamlss implementa varias funciones smooth que suelen dar buenos resultados. 

```{r}

modelo_gam <- gam(Gama ~ s(Engine) + s(Power) + Transmission,
                family=binomial,
                data    = data)

summary(modelo_gam)
```

Debido a la incorporación de las funciones no lineales (smoothers), hay que ser cauto a la hora de interpretar los coeficientes y los errores mostrados en el summary. Los coeficientes y errores de los predictores con funciones smooth (Engine y Power) contemplan únicamente la parte lineal, ignorando la no lineal. En el caso de los predictores lineales (Transmission) sus errores se estiman asumiendo que los términos con smoother son fijos, y no contemplan la incertidumbre introducida al ajustar cada una de las funciones smooth.

Para conocer la contribución total (lineal y no lineal) de los predictores transformados por funciones smooth se puede emplear la función anova. Esta función calcula el impacto que tiene en el modelo (en términos de grados de libertad totales, AIC y significancia estadística) el eliminar cada uno de los predictores de forma secuencial.

```{r}
modelo_gam
anova(modelo_gam, test= "F")
plot(modelo_gam)
AIC(logit3, modelo_gam)
```

El modelo GAM ha conseguido reducir todavía más el valor AIC y la distribución de sus residuos ha mejorado ligeramente.
